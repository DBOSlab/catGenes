#' Writes a concatenated (non-interleaved) or combined (interleaved) nexus-formatted
#' dataset for multigene phylogenetic analysis
#'
#' @author Domingos Cardoso, Quezia Cavalcante, and Bruno Vilela
#'
#' @description Writes a final concatenated (non-interleaved) or combined (interleaved)
#' nexus-formatted dataset for multigene phylogenetic analysis, from the resulting list
#' of equally-sized dataframes containing the input gene datasets, as generated by
#' the functions \code{\link{catfullGenes}} or \code{\link{catmultGenes}}. Depending on the chosen arguments the
#' final nexus-formatted file will or will not include a preliminary command block (including
#' the charset of each partition).
#'
#' @usage
#' writeNexus(x,
#'            file,
#'            bayesblock = TRUE,
#'            interleave = TRUE)
#'
#' @param x The object to be written, a list of equally-sized dataframes containing
#' the input gene datasets, as generated by \\code{\link{catfullGenes}} or
#' \code{\link{catmultGenes}}.
#'
#' @param file Either a character string naming a file or a \code{\link{connection}}
#'  open for writing.
#'
#' @param bayesblock Logical, if \code{FALSE} will not create a preliminary Mr.Bayes
#' command block including the charsets showing the number of characters of each
#' individual gene partition.
#'
#' @param interleave Logical, if \code{FALSE} will fully concatenate the DNA alignments
#' without individually distinguishing each gene dataset as separate named partitions
#' within the complete matrix.
#'
#' @seealso \code{\link{catfullGenes}}
#' @seealso \code{\link{catmultGenes}}
#'
#' @examples \dontrun{
#' data(DNAlignments)
#' datasets4comb <- catfullGenes(DNAlignments,
#'                               shortaxlabel = TRUE,
#'                               missdata = FALSE,
#'                               outgroup = "Abutilon_costicalyx")
#'
#' writeNexus(datasets4comb,
#'            file = "filename.nex",
#'            bayesblock = TRUE,
#'            interleave = TRUE)
#' }
#'
#' @importFrom dplyr bind_rows
#' @importFrom R.utils insert
#' @importFrom tidyr unite
#' @importFrom utils write.table
#'
#' @export

writeNexus <- function(x, file, bayesblock = TRUE, interleave = TRUE) {

  datset <- .namedlist(x)

  numberinputdatset <- length(datset)

  # Unlist and rename an input list from genefullcomp function
  if (numberinputdatset == 1) {
    datset <- unlist(datset, recursive = FALSE)
    names(datset) <- gsub(".*[.]", "", names(datset))

    for (i in 1:length(datset)) {
      datset[[i]]$species <- as.character(datset[[i]]$species)
      datset[[i]]$sequence <- as.character(datset[[i]]$sequence)}
  }

  numberdatset <- length(datset)

  if (numberdatset == 1){
    stop("You must provide a file generated by the genefullcomp
          Find help also at DBOSLab-UFBA (Domingos Cardoso; cardosobot@gmail.com)")
  }

  genenames <- names(datset)

  cat("You are combining the following gene datasets:", "", sep = "\n")
  cat(cat(genenames, sep = ", "), "", sep = "\n")
  cat(cat("Total number of datasets:", numberdatset), "", sep = "\n")

  numbchar <- lapply(datset, function(x) nchar(x[1, 2]))

  # Making all separate dataset within the list the same size to transforme into a dataframe with NAs whenever there is no sequence
  #datasets <- lapply(datasets, `length<-`, max(lengths(datasets)))

  writtenby <- paste("[DBOSLab-UFBA R scripts, ", date(), "]\n\n", sep = "")
  nexus <- paste("#NEXUS", "", sep = "\n")
  begindata <- paste("BEGIN DATA;")
  dimname <- paste("DIMENSIONS")
  ntax <- paste0("NTAX=", length(rownames(datset[[1]])))

  total_numbchar <- sum(unlist(numbchar))
  series_numbchar <- paste(lapply(numbchar, function(x) unlist(x)))
  list_nchars1 <- paste0(genenames,
                         rep("=", times = numberdatset),
                         series_numbchar)
  list_nchars2 <- paste(list_nchars1, collapse = " + ")

  nchartotal <- paste0("NCHAR=",
                       total_numbchar, "; [",
                       list_nchars2,
                       "]")
  dimensions <- paste(dimname, ntax, nchartotal, sep = " ")
  formatinter <- paste("FORMAT DATATYPE=DNA GAP=- MISSING=? INTERLEAVE=YES;")
  format <- paste("FORMAT DATATYPE=DNA GAP=- MISSING=? INTERLEAVE=NO;")

  cat("Your final dataset will have these DIMENSIONS:", "", sep = "\n")
  cat(nchartotal, "", sep = "\n")
  cat(ntax, "", sep = "\n")

  matrix <- paste("MATRIX", "", sep = "\n")

  # Calculating the space between the taxon labels and corresponding DNA sequence for each dataset
  # First calculate how many letters there are in each taxon in each dataset
  letrs_taxlabs <- lapply(datset, function(x) nchar(x$species))

  # Setting the maximum of space based on the largest taxonlabel
  maxletrs_taxlabs <- lapply(letrs_taxlabs, function(x) max(x)+5) #just increase this last number if we want to add more space
  maxletrs_taxlabs <- max(unlist(maxletrs_taxlabs))

  # Pad a string inside a list of dataframes by adding numbers or names at any
  # position in the specific column
  f_b <- function(x, y) {
    for (i in 1:length(x$species)) {
      x$species[i] <- paste0(x$species[i], paste0(rep(" ", y - nchar(x$species[i])),
                                                  collapse = ""))
    }
    x
  }
  datset <- lapply(datset, f_b,
                   y = maxletrs_taxlabs)


  if(interleave){
    cat("Combining genes as interleave...", "", sep = "\n")
    # Uniting the two columns inside a list of dataframes
    datset <- lapply(datset, function(x) tidyr::unite(x, "sequences", colnames(x), sep = " "))

    # Adding the gene name and two extra spaces below each gene dataset
    ex_datset <- mapply(function(x, y) rbind(y, x, "", ""),
                        x = datset, y = paste0("[", as.list(genenames), "]"),
                        SIMPLIFY = FALSE)

    # Combining the dataframes inside the list into a single dataframe
    genes <- data.frame(dplyr::bind_rows(ex_datset, .id = NULL)) # Somehow it was not working with .id="sequences" so I had to exclude the next line
    #genes <- data.frame(genes[, 2])
    colnames(genes) <- "sequences"
    genes$sequences <- as.character(genes$sequences)

    # Writing the data command block
    #n <- dim(genes)[1]
    #genes <- genes[1:(n-3),] # To remove few paragraphs after the matrix block and before the "; END;"
    end <- paste(";","END;", sep = "\n")
    genes[nrow(genes) + 1, ] <- end
    colnames(genes) <- paste(nexus,
                             writtenby,
                             begindata,
                             dimensions,
                             formatinter,
                             matrix,
                             sep = "\n")

  }else{
    cat("Concatenating genes in full, non-interleaved alignment...", "", sep = "\n")
    # Uniting the two columns inside just the first dataframe
    datset[[1]] <- tidyr::unite(datset[[1]], "sequences", colnames(datset[[1]]), sep = " ")

    # Deleting the species collumn in the remaining dataset
    for (i in 2:numberdatset){
      datset[[i]] <- data.frame(sequences=datset[[i]][,2])
    }

    ex_datset <- do.call("cbind", datset)
    names(ex_datset) <- paste("sequences", 1:length(ex_datset), sep = "")

    # Uniting all columns
    genes <- tidyr::unite(ex_datset, "sequences", sep = "")
    genes$sequences <- as.character(genes$sequences)

    # Writing the data command block
    #n <- dim(genes)[1]
    #genes <- genes[1:(n-3),] #to remove few paragraphs after the matrix block and before the "; END;"
    end <- paste(";","END;", sep = "\n")
    genes[nrow(genes) + 1, ] <- end
    colnames(genes) <- paste(nexus,
                             writtenby,
                             begindata,
                             dimensions,
                             format,
                             matrix,
                             sep = "\n")

  }


  if(bayesblock){
    cat(cat("Building a preliminary Mr.Bayes command block...", "", sep = "\n"))
    genes[nrow(genes) + 2, ] <- ""
    mrbayes <- paste("begin mrbayes;",
                     "set autoclose=yes;",
                     sep = "\n")
    genes[nrow(genes) + 2, ] <- mrbayes
    out_tax <- paste("outgroup WRITE_YOUR_OUTGROUP;",
                     sep = "\n")
    genes[nrow(genes) + 2, ] <- out_tax

    # Creating the charset block
    list_nchars3 <- paste0(paste(sapply(numbchar, function(x) unlist(x))),
                           rep("=", times = numberdatset), genenames)

    charsets <- paste(rep("charset", times = numberdatset), genenames, "= ")

    # Calculating the end of each gene with a cumulative sum of each gene size
    endgene <- paste(cumsum(series_numbchar))

    # Calculating the begining of each gene
    startgene <- lapply(as.numeric(endgene), function(x) x+1)

    # Dropping last value in the list
    startgene <- startgene[1:(length(startgene)-1)]

    # Insert the number "1" in the first position of the list
    startgene <- paste(R.utils::insert(startgene, ats = 1, values = 1))

    charsetsblock <- paste0(charsets,
                            startgene,
                            rep("-", times = numberdatset),
                            endgene,
                            paste0("; [", list_nchars3, "]"),
                            sep = "\n")
    charsetsblock <- paste(charsetsblock, collapse = "")

    genes[nrow(genes) + 2, ] <- paste(charsetsblock)

    partition <- paste(paste0("partition regions = ", numberdatset, ": ",
                              paste(genenames, collapse = ", "), ";"),
                       "set partition = regions;",
                       sep = "\n")
    genes[nrow(genes) + 2, ] <- partition

    sitesout <- paste("[IF YOU WANT TO EXCLUDE AN SPECIFIC PARTITION OR a NUMBER OF SITES INSIDE THE MATRIX...]",
                      "[UNBRACKET THE FOLLOWING:]",
                      "[exclude gene1;]",
                      "[exclude 20-30 234-456;] [NOTE THAT YOU ARE DELETING TWO BLOCKS OF SITES IN THE MATRIX]",
                      sep = "\n")
    genes[nrow(genes) + 2, ] <- sitesout

    taxout <- paste("[IF YOU WANT TO DELETE AN SPECIFIC SET OF TAXA OR AN SPECIFIC TAXA...]",
                    "[UNBRACKET THE FOLLOWING:]",
                    "[taxaset genus1 = 10-30;] [HERE YOU HAVE CREATED A TAXASET NAMED AS GENUS1 FOR TAXA/SEQUENCES 10-30]",
                    "[delete = genus1;] [NOW YOU ARE DELETING ALL TAXA/SEQUENCES FROM 10-30]",
                    "[delete = 1 4 8;] [NOW YOU ARE DELETING JUST THE TAXA/SEQUENCES 1, 4 and 8.
                    YOU COULD ALSO USE THE ACTUAL NAME OF THE TAXA/TERMINAL AS IN THE MATRIX INSTEAD OF THEIR POSITION.
                    MAKE SURE THE NAMES OR POSITIONS OF THE TAXA TO BE DELETED ARE NOT SEPARATE BY COMMA]",
                    sep = "\n")
    genes[nrow(genes) + 2, ] <- taxout

    lset <- paste("lset applyto=(1) nst=6 rates=invgamma; [CHANGE THE PARAMETERS ACCORDINGLY]",
                  "lset applyto=(2,3) nst=6 rates=gamma; [CHANGE THE PARAMETERS ACCORDINGLY]",
                  sep="\n")
    genes[nrow(genes) + 2, ] <- lset

    prset <- paste("unlink statefreq=(all) revmat=(all) shape=(all) pinvar=(all); [CHANGE THE PARAMETERS ACCORDINGLY]",
                   "prset applyto=(all) ratepr=variable; [CHANGE THE PARAMETERS ACCORDINGLY]",
                   sep = "\n")
    genes[nrow(genes) + 2, ] <- prset

    mcmc <- paste("[SET YOUR MCMC PARAMETERS ACCORDINGLY]",
                  "mcmc ngen=10000000 printfreq=10000 samplefreq=10000 nchains=8
                  nruns=2 savebrlens=yes filename=WRITE_YOUR_TAXON_comb_Bayesian;",
                  sep = "\n")
    genes[nrow(genes) + 2, ] <- mcmc

    log <- paste("log start filename=WRITE_YOUR_TAXON_comb_Bayesian.log append;")
    genes[nrow(genes) + 2, ] <- log

    sump <- paste("sump;",
                  "sumt relburnin=yes burninfrac=0.25;",
                  "end;",
                  sep = "\n")
    genes[nrow(genes) + 2, ] <- sump
  }

  zz <- file(file, "w")
  write.table(genes, zz,
              append = FALSE, quote = FALSE, sep = " ",
              eol = "\n", na = "", dec = ".", row.names = FALSE,
              col.names = TRUE)

  cat("Gene concatenation is finished!", "",
      sep = "\n")

  close(zz)
}
